#! /usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

use Data::Dumper;

use Sendmail::QidTrace qw/match_line/;

our $VERSION = '0.31';  #TBD: Design change Thu2011_0920

my $DEBUG = 0;  # Set to 1 to enable debug stmts.
                # Set to 0 to run tests & for normal operation.

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any
#ORG my $window_size = 100;  #use 1400 to get all matches; Use 100 to debug.
my $window_size = 1400;  #use 1400 (or 2800?) to get all matches;
$window_size    = 40 if ($DEBUG) ;

my $email_address;
my $emit_line_numbers = 1;
my $output_start_column = 0;
my $output_length       = 0;  # default to the whole line

unless (GetOptions(
            # input matching
            'window-size=i' => \$window_size,
            'match-pattern=s' => \$email_address,
            # output formatting
            'number-output' => \$emit_line_numbers,
            # control what part of the match line we emit by calls to substr
            'start-column=i'  => \$output_start_column,
            'output-length=i' => \$output_length)) {
    die usage();
}
unless ($email_address) {
    die "no email address found on command line\n\n", usage();
}

my $qt = new Sendmail::QidTrace::Queue({match        => $email_address,
                                        window_size  => $window_size,
                                        line_numbers => $emit_line_numbers});
my %each_line;

while (<>) {
    chomp;
#TBD: Should this be global var?
my $line;
my $num;

    my $lref;
    my %lh;
    #TBR? $each_line{num}  = $.;
    #TBR? $each_line{line} = $_;
    #F $qt->push_onto_leading_array( \%each_line );
    $qt->push_onto_leading_array( {num  => $.,
                                   line => $_} );
    #DBG print "DBG.while: \$.: ,$.,\n" if ($DEBUG);

    # Fill the _leading array before checking for matches.
    if ( $qt->size_of_leading_array  > $window_size ) {
        #OK.ORG  $line = $qt->shift_off_leading_array();
        # Deref the hash & get value for key 'line':
        #TBF  $line = ${ $qt->shift_off_leading_array() }{line} ;
        #TBR  ($line, $num) = ${ $qt->shift_off_leading_array() };
        #TBR? $num  = ${ $qt->shift_off_leading_array() }{num} ;
        my $leadref  =  $qt->shift_off_leading_array() ;
                my %leadh   = %$leadref;
                #TBR my $ln   = $leadh{line};
                my $line   = $leadh{line};
                #TBR my $lnum = $leadh{num};
                my $num = $leadh{num};

        #DBG print "DBG.window_filled: \$num: ,$num,\n" if ($DEBUG);
        my ($match_email, $match_qid) = match_line($email_address, $line);
        #
        next if ( $match_qid eq '' ); # No qid found: skip to next line.
          #TBD: Does this skip lines w/ addr & no qid?  Maybe move it down or rm?
          # Are there such lines?
        #
        if ($match_email) {
            print "DBG.email_match_found: \$num: ,$num,\n" if ($DEBUG);
            $qt->add_match({match => $match_email,
                            qid   => $match_qid,
                            line  => ($output_length
                                      ? substr($line, $output_start_column, $output_length)
                                      : substr($line, $output_start_column)),
                            num   => $num });
            #
            # Check for matching qid's in the buffer.
            foreach $lref ( $qt->get_leading_array, $qt->get_trailing_array ) {
                %lh   = %$lref;
                my $ln   = $lh{line};
                my $lnum = $lh{num};
                #OK.ORG  if (defined $ln && ($ln =~ /$match_qid/) && ($ln !~ $line) ){ #}
                #OK.? if (defined $ln && ($ln =~ /$match_qid/) && ($ln ne $line) ){ #}
                if (defined $ln && ($ln =~ /$match_qid/) ){
                    my ($match_email, $match_qid) = match_line($email_address, $ln);

                    # Skip current line to avoid adding a duplicate line in o/p,
                    # if it has the matching email addr and a matching qid.
                    # Add this line to the o/p only when it is shifted off the 
                    # leading array to check its email addr.
                    next if ($match_email eq $email_address);

                    print "DBG.buffer_match_found: \$num: ,$num,\n" if ($DEBUG);
                    $qt->add_match({match => $match_email,
                                    qid   => $match_qid,
                                    line  => ($output_length
                                              ? substr($ln, $output_start_column, $output_length)
                                              : substr($ln, $output_start_column)),
                                    num   => $lnum });
                    #TBD: Delete line from buffer, or mark it as saved so ignore it to avoid duplicates.
                }
            }  # End foreach $lref.
            next;  # Read next i/p line after finding a matching email.
                   # Do not push it onto @_trailing.
        }  # End (if ($match_email)
        #
        # Save line to trailing array if not added to %_seen hash.
        #OK.ORG  $qt->push_onto_trailing_array ($line);
        #
        #
        #
        ###
        ###TBD Wed2011_0921_18:55 : Chg from \%lh to anon hash ref?
        ### Avoid REUSED ADDR in HASH at %_trailing.
        #
        $qt->push_onto_trailing_array ( {num  => $num,
                                         line => $line} );
        if ( $qt->size_of_trailing_array  >= $window_size ) {
            #OK.ORG $line = $qt->shift_off_trailing_array();
            $line = ${ $qt->shift_off_trailing_array() }{line} ;
            #TBD: Maybe check the line for matching qid before tossing.
        }
    } # End if (leading_array test)
    #TBR? %each_line = ();
} # End of while loop.


$qt->drain_queue($output_start_column, $output_length);

#TBR =begin printOK

# Print all matching lines from the %_seen hash.
#DBG print "LineNumber; qid; EmailAddr:\n";
#DBG print "===========================\n";
foreach  my $k ( sort keys  %{ $qt->get_seen_hash } ) {
    #TBF: Specifying cmd line param '-s' can affect the sorted o/p.  Fix this.
    my $h = shift ( @{ ${ $qt->get_seen_hash }{$k} } ) ;
    print "${$h}{num}; " if ($DEBUG);
    #DBG print "${$h}{qid} if ($DEBUG); ";
    #DBG print "${$h}{match}:\n" if ($DEBUG);
    print "${$h}{line}\n";
    foreach ( @{ ${ $qt->get_seen_hash }{$k} } ) {
        print "**** ${$_}{num}" if ($DEBUG);;
        #DBG print "${$_}{qid}; " if ($DEBUG);
        #DBG print "${$_}{match}:\n" if ($DEBUG);
        print "**** ${$_}{line}\n";
    };
}


#TBR =end printOK


#TBR =cut



=pod

=head2 Print All Matching Lines

Use two loops to print the collection of o/p lines, grouped 
and sorted by qid.

The outer loop dereferences the hash ref,
  selects the keys (which are qid's),
  sorts the list by qid,
  then iterates over its block using each qid as the index value.

The inner loop takes the qid as a key for the %_seen hash,
  gets the hash value for that key (which is a ref to an array),
  dereferences the array,
  iterates over every member of that array,
  and prints each line found in that array.

=cut




exit;

sub usage {
    return <<"eousage";
usage $prog: [options] -m match_string <log_files>

$prog is a filter for sendmail log files.
It follows sendmails queue id strings so that sequences of log lines can be found.

Options to control the matching

-match-pattern string    log lines are matched against this literal (not regex) pattern.
                         typical usage is an email address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and behind the current line
                         is kept.  Matches will be found in this buffer.
                         Default: 100

Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}

