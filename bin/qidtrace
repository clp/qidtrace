#! /usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

use Data::Dumper;

use Sendmail::QidTrace qw/match_line/;

our $VERSION = '0.01';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any
#TBD: use window_size smaller than data file size, or fix the read loop
# to handle that situation.
#ORG my $window_size = 100;
my $window_size = 10;
my $email_address;
my $emit_line_numbers = 0;
my $output_start_column = 0;
my $output_length       = 0;  # default to the whole line

unless (GetOptions(
            # input matching
            'window-size=i' => \$window_size,
            'match-pattern=s' => \$email_address,
            # output formatting
            'number-output' => \$emit_line_numbers,
            # control what part of the match line we emit by calls to substr
            'start-column=i'  => \$output_start_column,
            'output-length=i' => \$output_length)) {
    die usage();
}
unless ($email_address) {
    die "no email address found on command line\n\n", usage();
}

my $qt = new Sendmail::QidTrace::Queue({match        => $email_address,
                                        window_size  => $window_size,
                                        line_numbers => $emit_line_numbers});
while (<>) {
    chomp;
    $qt->push_onto_leading_array( $_ );

    # Fill the _leading array before checking for matches.
    if ( $qt->size_of_leading_array  >= $window_size ) {
        #TBD.1847: This line breaks code, but it seems vital at this place;
        # find & fix the problem (Is it $_ explicit vs implicit?):
        my $ln = $qt->shift_off_leading_array();
        my ($match_email, $match_qid) = match_line($email_address, $ln);
        print "DBG: \$match_email, \$match_qid:  $match_email  ,   $match_qid\n";
        #
        next if ( $match_qid eq '' ); # No qid found: skip to next line.
        #
        if ($match_email || ( grep {m/$match_qid/}  $qt->get_seen_lines )) {
            $qt->add_match({match => $match_email,
                            qid   => $match_qid,
                            line  => ($output_length
                                      ? substr($ln, $output_start_column, $output_length)
                                      : substr($ln, $output_start_column)),
                            num   => $. });
            next;
        }
        #
        if ( $match_qid ) {
            # qid found, but it does not match any saved qid's.
            # Add the current line to bottom of queue for later matching.
            #TBR? $qt->push_onto_leading_array( $_ );
            #
            # Check the size of both arrays, and manage queue if needed.
            #TBR? if ( $qt->size_of_leading_array  >= $window_size ) {
                #TBD: Don't re-process the line.
                #TBR? $_ = $qt->shift_off_leading_array();
                #TBR? ($match_email, $match_qid) = match_line($email_address, $_);
                #TBR? if ( exists $qt->{$match_qid} ) {
                if ( grep {m/$match_qid/}  $qt->get_seen_lines ) {
                    $qt->add_match({match => $match_email,
                                    qid   => $match_qid,
                                    line  => ($output_length
                                              ? substr($ln, $output_start_column, $output_length)
                                              : substr($ln, $output_start_column)),
                                    num   => $. });
                    next;
                }
                #TBR? }
                # Save to array if not added to queue.
                $qt->push_onto_trailing_array ($ln);
            #TBR? }
            if ( $qt->size_of_trailing_array  >= $window_size ) {
                #TBD.1847 : Diff results when explicitly using $_:
                $ln = $qt->shift_off_trailing_array();
                #TBD: Check the line for matching qid.
                #DBG print "DBG: After shift_off_trailing: \$ln: ", $ln, "\n";
            }
        }
    }
} # End of while loop.

#DBG print "DBG: Dumper (\$qt):\n";
#DBG print Dumper ($qt);

###
# $qt->drain_queue();
my @lines_to_drain = ($qt->get_leading_array(), $qt->get_trailing_array );
#DBG print "DBG drain queue-read loop: \@lines_to_drain: ,@lines_to_drain,\n";

#ORG while ( $_ = ($qt->get_leading_array(), $qt->get_trailing_array ) ) {
#F while ( $_ = <@lines_to_drain>  ) {
#F while ( <@lines_to_drain>  ) {
foreach  my $ltd ( @lines_to_drain ) {
    #DBG print "DBG drain queue-read loop: \$ltd: ,$ltd,\n";
    #TBD: Do not re-process each line.
    my ($match_email, $match_qid) = match_line($email_address, $ltd);
    if ($match_email || ( grep {m/$match_qid/}  $qt->get_seen_lines )) {
      #F if ( grep {m/$match_qid/}  $qt->get_seen_lines ) {
        $qt->add_match({match => $match_email,
                        qid   => $match_qid,
                        line  => ($output_length
                                  ? substr($ltd, $output_start_column, $output_length)
                                  : substr($ltd, $output_start_column)),
                        num   => $. });
        next;
        #}
    }
}


print "DBG: Dumper (\$qt:keys of %_seen):\n";
#DBG print Dumper ($qt);
foreach my $k ( sort $qt->get_seen_lines ) {
    # Note: Sendmail::QidTrace::Queue::add_match() must use $mo->{line} as hash key,
    # to get the line printed.
    # TBF: Specifying cmd line param '-s' can affect the sorted o/p.  Fix this.
    print $k, "\n";
}

exit;

sub usage {
    return <<"eousage";
usage $prog: [options] -m match_string <log_files>

$prog is a filter for sendmail log files.
It follows sendmails queue id strings so that sequences of log lines can be found.

Options to control the matching

-match-pattern string    log lines are matched against this literal (not regex) pattern.
                         typical usage is an email address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and behind the current line
                         is kept.  Matches will be found in this buffer.
                         Default: 100

Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}

