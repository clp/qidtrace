#! /usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

use Data::Dumper;

use Sendmail::QidTrace qw/match_line/;

our $VERSION = '0.01';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any
#TBD: use window_size smaller than data file size, or fix the read loop
# to handle that situation.
#ORG my $window_size = 100;
my $window_size = 5;
my $email_address;
my $emit_line_numbers = 0;
my $output_start_column = 0;
my $output_length       = 0;  # default to the whole line

unless (GetOptions(
            # input matching
            'window-size=i' => \$window_size,
            'match-pattern=s' => \$email_address,
            # output formatting
            'number-output' => \$emit_line_numbers,
            # control what part of the match line we emit by calls to substr
            'start-column=i'  => \$output_start_column,
            'output-length=i' => \$output_length)) {
    die usage();
}
unless ($email_address) {
    die "no email address found on command line\n\n", usage();
}

my $qt = new Sendmail::QidTrace::Queue({match        => $email_address,
                                        window_size  => $window_size,
                                        line_numbers => $emit_line_numbers});
while (<>) {
    chomp;
    $qt->push_onto_leading_array( $_ );

    if ( $qt->size_of_leading_array  >= $window_size ) {
        # Fill the _leading array before checking for matches.
        my ($match_email, $match_qid) = match_line($email_address, $_);
        #DBG print "DBG: \$match_email, \$match_qid:  $match_email  ,   $match_qid\n";
        #
        next if ( $match_qid eq '' ); # No qid found: skip to next line.
        #
        if ($match_email || ( grep {m/$match_qid/}  $qt->get_seen_lines )) {
            $qt->add_match({match => $match_email,
                            qid   => $match_qid,
                            line  => ($output_length
                                      ? substr($_, $output_start_column, $output_length)
                                      : substr($_, $output_start_column)),
                            num   => $. });
            next;
        }
        #
        if ( $match_qid ) {
            # qid found, but it does not match any saved qid's.
            # Add the current line to bottom of queue for later matching.
            $qt->push_onto_leading_array( $_ );
            #
            # Check the size of both arrays, and manage queue if needed.
            if ( $qt->size_of_leading_array  >= $window_size ) {
                #TBD: Don't re-process the line.
                $qt->shift_off_leading_array();
                ($match_email, $match_qid) = match_line($email_address, $_);
                if ( exists $qt->{$match_qid} ) {
                    $qt->add_match({match => $match_email,
                                    qid   => $match_qid,
                                    line  => ($output_length
                                              ? substr($_, $output_start_column, $output_length)
                                              : substr($_, $output_start_column)),
                                    num   => $. });
                    next;
                }
                $qt->push_onto_trailing_array ($_);
            }
            if ( $qt->size_of_trailing_array  >= $window_size ) {
                $qt->shift_off_trailing_array();
                #TBD: Check the line for matching qid.
                #DBG print "DBG: After shift_off_trailing: \$_: ", $_, "\n";
            }
        }
    }
} # End of while loop.

#DBG print "DBG: Dumper (\$qt):\n";
#DBG print Dumper ($qt);

###
# $qt->drain_queue();
while ( my $_ = $qt->shift_off_trailing_array(), $qt->shift_off_leading_array ) {
    #DBG print "DBG drain queue-read loop: \$_: ,$_,\n";
    #TBD: Do not re-process each line.
    my ($match_email, $match_qid) = match_line($email_address, $_);
    if ( grep {m/$match_qid/}  $qt->get_seen_lines ) {
        $qt->add_match({match => $match_email,
                        qid   => $match_qid,
                        line  => ($output_length
                                  ? substr($_, $output_start_column, $output_length)
                                  : substr($_, $output_start_column)),
                        num   => $. });
        next;
    }
}


print "DBG: Dumper (\$qt:keys of %_seen):\n";
#DBG print Dumper ($qt);
foreach my $k ( $qt->get_seen_lines ) {
    # Note: Sendmail::QidTrace::Queue::add_match() must use $mo->{line} as hash key,
    # to get the line printed:
    print Dumper ($k);
}

exit;

sub usage {
    return <<"eousage";
usage $prog: [options] -m match_string <log_files>

$prog is a filter for sendmail log files.
It follows sendmails queue id strings so that sequences of log lines can be found.

Options to control the matching

-match-pattern string    log lines are matched against this literal (not regex) pattern.
                         typical usage is an email address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and behind the current line
                         is kept.  Matches will be found in this buffer.
                         Default: 100

Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}

