#! /usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

use Data::Dumper;

use Sendmail::QidTrace qw/match_line/;

our $VERSION = '0.10';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any
# Note: use window_size smaller than data file size, or fix 
# the read loop to handle that situation.
#ORG my $window_size = 100;
#MAX my $window_size = 1400;
my $window_size = 100;
my $email_address;
my $emit_line_numbers = 0;
my $output_start_column = 0;
my $output_length       = 0;  # default to the whole line

unless (GetOptions(
            # input matching
            'window-size=i' => \$window_size,
            'match-pattern=s' => \$email_address,
            # output formatting
            'number-output' => \$emit_line_numbers,
            # control what part of the match line we emit by calls to substr
            'start-column=i'  => \$output_start_column,
            'output-length=i' => \$output_length)) {
    die usage();
}
unless ($email_address) {
    die "no email address found on command line\n\n", usage();
}

my $qt = new Sendmail::QidTrace::Queue({match        => $email_address,
                                        window_size  => $window_size,
                                        line_numbers => $emit_line_numbers});
while (<>) {
    chomp;
    $qt->push_onto_leading_array( $_ );

    # Fill the _leading array before checking for matches.
    if ( $qt->size_of_leading_array  >= $window_size ) {
        my $ln = $qt->shift_off_leading_array();
        my ($match_email, $match_qid) = match_line($email_address, $ln);
        #
        next if ( $match_qid eq '' ); # No qid found: skip to next line.
        #
        my @lines = ($qt->get_leading_array(), $qt->get_trailing_array );
        #TBD: Chg from get_seen_qids to @lines for performance?
        if ($match_email || ( grep {m/$match_qid/}  $qt->get_seen_qids )) {
            $qt->add_match({match => $match_email,
                            qid   => $match_qid,
                            line  => ($output_length
                                      ? substr($ln, $output_start_column, $output_length)
                                      : substr($ln, $output_start_column)),
                            num   => $. });
            next;
        }
        #
        if ( $match_qid ) {
            # qid found, but it does not match any saved qid's.
            #TBD: Chg to @lines?:
            if ( grep {m/$match_qid/}  $qt->get_seen_qids ) {
                $qt->add_match({match => $match_email,
                                qid   => $match_qid,
                                line  => ($output_length
                                          ? substr($ln, $output_start_column, $output_length)
                                          : substr($ln, $output_start_column)),
                                num   => $. });
                next;
            }
            # Save to array if not added to queue.
            $qt->push_onto_trailing_array ($ln);
            if ( $qt->size_of_trailing_array  >= $window_size ) {
                $ln = $qt->shift_off_trailing_array();
                #TBD: Maybe check the line for matching qid before tossing.
            }
        }
    }
} # End of while loop.


$qt->drain_queue();


# Print all matching lines from the %_seen hash.
foreach  my $k ( sort keys  %{ $qt->get_seen_hash } ) {
    #TBF: Specifying cmd line param '-s' can affect the sorted o/p.  Fix this.
    print shift ( @{ ${ $qt->get_seen_hash }{$k} } ) , "\n";
    foreach ( @{ ${ $qt->get_seen_hash }{$k} } ) {
        print "**** $_\n";
    };
}



=pod

=head2 Print All Matching Lines

Use two loops to print the collection of o/p lines, grouped 
and sorted by qid.

The outer loop dereferences the hash ref,
  selects the keys (which are qid's),
  sorts the list by qid,
  then iterates over its block using each qid as the index value.

The inner loop takes the qid as a key for the %_seen hash,
  gets the hash value for that key (which is a ref to an array),
  dereferences the array,
  iterates over every member of that array,
  and prints each line found in that array.

=cut




exit;

sub usage {
    return <<"eousage";
usage $prog: [options] -m match_string <log_files>

$prog is a filter for sendmail log files.
It follows sendmails queue id strings so that sequences of log lines can be found.

Options to control the matching

-match-pattern string    log lines are matched against this literal (not regex) pattern.
                         typical usage is an email address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and behind the current line
                         is kept.  Matches will be found in this buffer.
                         Default: 100

Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}

