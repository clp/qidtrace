#! /usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

use Data::Dumper;

use Sendmail::QidTrace qw/match_line/;

our $VERSION = '0.01';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any
#ORG my $window_size = 100;
my $window_size = 5;
my $email_address;
my $emit_line_numbers = 0;
my $output_start_column = 0;
my $output_length       = 0;  # default to the whole line

unless (GetOptions(
            # input matching
            'window-size=i' => \$window_size,
            'match-pattern=s' => \$email_address,
            # output formatting
            'number-output' => \$emit_line_numbers,
            # control what part of the match line we emit by calls to substr
            'start-column=i'  => \$output_start_column,
            'output-length=i' => \$output_length)) {
    die usage();
}
unless ($email_address) {
    die "no email address found on command line\n\n", usage();
}

my $qt = new Sendmail::QidTrace::Queue({match        => $email_address,
                                        window_size  => $window_size,
                                        line_numbers => $emit_line_numbers});
while (<>) {
    chomp;
    my ($match_email, $match_qid) = match_line($email_address, $_);
    #DBG print "DBG: \$match_email, \$match_qid: ", $match_email, " ,  ", $match_qid, "\n";
    # if ($match_email || $match_qid) {
    #     $qt->add_match({match => $match_email,
    #                     qid   => $match_qid,
    #                     line  => ($output_length
    #                               ? substr($_, $output_start_column, $output_length)
    #                               : substr($_, $output_start_column)),
    #                     num   => $. });
    # }
    #
    ### clp's code below.
    #
    if ( $match_qid eq '' ) { 
      # No qid found: skip to next line.
      next;
    }
    #OK.1 if ($match_email || ( $match_qid and exists $qt->{$match_qid} )) {
      #TMP No need to test $match_qid again, now that we skip lines w/o qid.
      #TBD: Replace _seen w/ accessor.
    #OK if ($match_email || ( grep {m/$match_qid/}  %{ $qt->{_seen} } )) {
    if ($match_email || ( grep {m/$match_qid/}  $qt->get_seen_lines )) {
        $qt->add_match({match => $match_email,
                        qid   => $match_qid,
                        line  => ($output_length
                                  ? substr($_, $output_start_column, $output_length)
                                  : substr($_, $output_start_column)),
                        num   => $. });
        next;
    }

    if ( $match_qid ) {
        # qid found, but it does not match saved qid's; 
        # add the current line to bottom of queue for later matching.
        $qt->push_onto_leading_array( $_ );
        #
        # Check the size of both arrays, and manage queue if needed.
        if ( $qt->size_of_leading_array  >= $window_size ) {
            #TBD: Don't re-process the line.
            my $line_from_queue = $qt->shift_off_leading_array();
            ($match_email, $match_qid) = match_line($email_address, $line_from_queue);
            if ( exists $qt->{$match_qid} ) {
                $qt->add_match({match => $match_email,
                                qid   => $match_qid,
                                line  => ($output_length
                                          ? substr($_, $output_start_column, $output_length)
                                          : substr($_, $output_start_column)),
                                num   => $. });
                next;
            }
            $qt->push_onto_trailing_array ($line_from_queue);
        }
        if ( $qt->size_of_trailing_array  >= $window_size ) {
            my $line_from_queue = $qt->shift_off_trailing_array();
            #TBD: Check the line for matching qid.
            #DBG print "DBG: After shift_off_trailing: \$line_from_queue: ", $line_from_queue, "\n";
        }
    }
} # End of while loop.

#DBG print "DBG: Dumper (\$qt):\n";
#DBG print Dumper ($qt);

###
# $qt->drain_queue();
while ( my $_ = $qt->shift_off_trailing_array(), $qt->shift_off_leading_array ) {
    #DBG print "DBG drain queue-read loop: \$_: ,$_,\n";
    #DBG print "DBG drain queue-read loop: \$_\n";
    #TBD: Do not re-process each line.
    #TBD: Replace _seen w/ accessor.
    my ($match_email, $match_qid) = match_line($email_address, $_);
    if ( grep {m/$match_qid/}  %{ $qt->{_seen} } ) {
        $qt->add_match({match => $match_email,
                        qid   => $match_qid,
                        line  => ($output_length
                                  ? substr($_, $output_start_column, $output_length)
                                  : substr($_, $output_start_column)),
                        num   => $. });
        next;
    }
}


print "DBG: Dumper (\$qt:keys of %_seen):\n";
#DBG print Dumper ($qt);
#TBD.not.working.yet  foreach my $k ( keys %{ $qt->shift_off_seen_hash() } ) {
#TBD: Make accessor for %_seen in QidTrace.pm.
foreach my $k ( keys %{ $qt->{_seen} } ) {
    # add_match() must use $mo->{line} as hash key, to get the line printed:
    print Dumper ($k);
}

exit;

sub usage {
    return <<"eousage";
usage $prog: [options] -m match_string <log_files>

$prog is a filter for sendmail log files.
It follows sendmails queue id strings so that sequences of log lines can be found.

Options to control the matching

-match-pattern string    log lines are matched against this literal (not regex) pattern.
                         typical usage is an email address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and behind the current line
                         is kept.  Matches will be found in this buffer.
                         Default: 100

Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}

