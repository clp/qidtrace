#! /usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

use Data::Dumper;

use Sendmail::QidTrace qw/match_line/;

our $VERSION = '0.01';

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any
# Note: use window_size smaller than data file size, or fix 
# the read loop to handle that situation.
#ORG my $window_size = 100;
my $window_size = 1400;
my $email_address;
my $emit_line_numbers = 0;
my $output_start_column = 0;
my $output_length       = 0;  # default to the whole line

unless (GetOptions(
            # input matching
            'window-size=i' => \$window_size,
            'match-pattern=s' => \$email_address,
            # output formatting
            'number-output' => \$emit_line_numbers,
            # control what part of the match line we emit by calls to substr
            'start-column=i'  => \$output_start_column,
            'output-length=i' => \$output_length)) {
    die usage();
}
unless ($email_address) {
    die "no email address found on command line\n\n", usage();
}

my $qt = new Sendmail::QidTrace::Queue({match        => $email_address,
                                        window_size  => $window_size,
                                        line_numbers => $emit_line_numbers});
while (<>) {
    chomp;
    $qt->push_onto_leading_array( $_ );

    # Fill the _leading array before checking for matches.
    if ( $qt->size_of_leading_array  >= $window_size ) {
        my $ln = $qt->shift_off_leading_array();
        my ($match_email, $match_qid) = match_line($email_address, $ln);
        #
        next if ( $match_qid eq '' ); # No qid found: skip to next line.
        #
        if ($match_email || ( grep {m/$match_qid/}  $qt->get_seen_lines )) {
            $qt->add_match({match => $match_email,
                            qid   => $match_qid,
                            line  => ($output_length
                                      ? substr($ln, $output_start_column, $output_length)
                                      : substr($ln, $output_start_column)),
                            num   => $. });
            next;
        }
        #
        if ( $match_qid ) {
            # qid found, but it does not match any saved qid's.
            if ( grep {m/$match_qid/}  $qt->get_seen_lines ) {
                $qt->add_match({match => $match_email,
                                qid   => $match_qid,
                                line  => ($output_length
                                          ? substr($ln, $output_start_column, $output_length)
                                          : substr($ln, $output_start_column)),
                                num   => $. });
                next;
            }
            # Save to array if not added to queue.
            $qt->push_onto_trailing_array ($ln);
            if ( $qt->size_of_trailing_array  >= $window_size ) {
                $ln = $qt->shift_off_trailing_array();
                #TBD: Maybe check the line for matching qid before tossing.
            }
        }
    }
} # End of while loop.



# $qt->drain_queue();
my @lines_to_drain = ($qt->get_leading_array(), $qt->get_trailing_array );

foreach  my $ltd ( @lines_to_drain ) {
    #TBD: Do not re-process each line.
    my ($match_email, $match_qid) = match_line($email_address, $ltd);
    if ($match_email || ( grep {m/$match_qid/}  $qt->get_seen_lines )) {
        $qt->add_match({match => $match_email,
                        qid   => $match_qid,
                        line  => ($output_length
                                  ? substr($ltd, $output_start_column, $output_length)
                                  : substr($ltd, $output_start_column)),
                        num   => $. });
        next;
    }
}


#TBD: Print each group of lines w/ matched qid's together.
#DBG print "DBG: Dumper (\$qt:keys of %_seen):\n";
#DBG print Dumper ($qt);
foreach my $k ( sort $qt->get_seen_lines ) {
    # Note: Sendmail::QidTrace::Queue::add_match() must use $mo->{line} as hash key,
    # to get the line printed.
    # TBF: Specifying cmd line param '-s' can affect the sorted o/p.  Fix this.
    print $k, "\n";
}

exit;

sub usage {
    return <<"eousage";
usage $prog: [options] -m match_string <log_files>

$prog is a filter for sendmail log files.
It follows sendmails queue id strings so that sequences of log lines can be found.

Options to control the matching

-match-pattern string    log lines are matched against this literal (not regex) pattern.
                         typical usage is an email address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and behind the current line
                         is kept.  Matches will be found in this buffer.
                         Default: 100

Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}

