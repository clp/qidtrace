#! /usr/bin/env perl

use strict;
use warnings;

use Getopt::Long;

use Data::Dumper;

use Sendmail::QidTrace qw/match_line/;

our $VERSION = '0.20';  #TBD: Design change Thu2011_0915

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any
#ORG my $window_size = 100;  #use 1400 to get all matches;
my $window_size = 50;  #use 1400 to get all matches;
my $email_address;
my $emit_line_numbers = 0;
my $output_start_column = 0;
my $output_length       = 0;  # default to the whole line

unless (GetOptions(
            # input matching
            'window-size=i' => \$window_size,
            'match-pattern=s' => \$email_address,
            # output formatting
            'number-output' => \$emit_line_numbers,
            # control what part of the match line we emit by calls to substr
            'start-column=i'  => \$output_start_column,
            'output-length=i' => \$output_length)) {
    die usage();
}
unless ($email_address) {
    die "no email address found on command line\n\n", usage();
}

my $qt = new Sendmail::QidTrace::Queue({match        => $email_address,
                                        window_size  => $window_size,
                                        line_numbers => $emit_line_numbers});
#TBD: Maybe initlz from $qt->get_seen_qids; ?
#TBD: Must this be global var?
my @saved_qids = ();
my %seen_qids  = ();
my @matching_lines = ();
my $line;

while (<>) {
    chomp;
    $qt->push_onto_leading_array( $_ );
    #TBR? $line = $qt->shift_off_leading_array();

    # Fill the _leading array before checking for matches.
    if ( $qt->size_of_leading_array  > $window_size ) {
        $line = $qt->shift_off_leading_array();
            ###############################################################
            #TBD.1: Assign $line here, or before this if() clause,
            #  so trailing array gets proper $line?
            #  But t/u319* fails when I tried moving it.  Check this logic asap.
            ###############################################################
        my ($match_email, $match_qid) = match_line($email_address, $line);
        #
        next if ( $match_qid eq '' ); # No qid found: skip to next line.
          #TBD: Does this skip lines w/ addr & no qid?  Maybe move it down or rm?
        #
        #ORG.1  if ($match_email || ( grep {m/$match_qid/}  @saved_qids )) { #}
        if ($match_email) {
            #TBR? print  $line, "\n";
            $qt->add_match({match => $match_email,
                            qid   => $match_qid,
                            line  => ($output_length
                                      ? substr($line, $output_start_column, $output_length)
                                      : substr($line, $output_start_column)),
                            num   => $. });
            #
            push (@saved_qids, $match_qid) unless ( $seen_qids{$match_qid}++ ); #TBR?
            #
            # Check for matching qid's in the buffer.
            foreach my $ln ( $qt->get_leading_array, $qt->get_trailing_array ) { 
                #TBR? push @matching_lines, $ln  if (defined $ln && $ln =~ /$match_qid/);
                if (defined $ln && $ln =~ /$match_qid/) {
                    my ($match_email, $match_qid) = match_line($email_address, $ln);
                    $qt->add_match({match => $match_email,
                                    qid   => $match_qid,
                                    line  => ($output_length
                                              ? substr($ln, $output_start_column, $output_length)
                                              : substr($ln, $output_start_column)),
                                    num   => $. });
                }
                #TBD: Delete line from buffer.
            }
            #TBR? print "**** $_\n"  foreach ( @matching_lines );
            #TBR? @matching_lines = ();
            next;
        };
    ###############################################################################
    #TBR?  } # End if (leading_array test)  # Move to after the save to @_trailing?
    ###############################################################################
        #
        # Save object to trailing array if not added to %_seen hash.
        $qt->push_onto_trailing_array ($line);
        if ( $qt->size_of_trailing_array  >= $window_size ) {
            $line = $qt->shift_off_trailing_array();
            #TBD: Maybe check the line for matching qid before tossing.
        }
    } # End if (leading_array test)
} # End of while loop.


$qt->drain_queue($output_start_column, $output_length, \@saved_qids, \%seen_qids);

#TBR =begin printOK

# Print all matching lines from the %_seen hash.
foreach  my $k ( sort keys  %{ $qt->get_seen_hash } ) {
    #TBF: Specifying cmd line param '-s' can affect the sorted o/p.  Fix this.
    print shift ( @{ ${ $qt->get_seen_hash }{$k} } ) , "\n";
    foreach ( @{ ${ $qt->get_seen_hash }{$k} } ) {
        print "**** $_\n";
    };
}


#TBR =end printOK


#TBR =cut



=pod

=head2 Print All Matching Lines

Use two loops to print the collection of o/p lines, grouped 
and sorted by qid.

The outer loop dereferences the hash ref,
  selects the keys (which are qid's),
  sorts the list by qid,
  then iterates over its block using each qid as the index value.

The inner loop takes the qid as a key for the %_seen hash,
  gets the hash value for that key (which is a ref to an array),
  dereferences the array,
  iterates over every member of that array,
  and prints each line found in that array.

=cut




exit;

sub usage {
    return <<"eousage";
usage $prog: [options] -m match_string <log_files>

$prog is a filter for sendmail log files.
It follows sendmails queue id strings so that sequences of log lines can be found.

Options to control the matching

-match-pattern string    log lines are matched against this literal (not regex) pattern.
                         typical usage is an email address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and behind the current line
                         is kept.  Matches will be found in this buffer.
                         Default: 100

Output options

-number-output  flag     emit the line number of the matching line on output

-start-column   int      Control what portion of the matching line is displayed.
                         start-column gives the first column of the output line displayed.
-output-length  int      Length of the output line before line numbering, if any.
eousage
}

