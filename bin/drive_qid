#! /usr/bin/env perl
#
# drive_qid  clpoda  2011_0930
## batbug:/home/clpoda/p/qidtrace/bin
## Time-stamp: <Tue 2011 Oct 04 12:18:39 PMPM clpoda>
#vi modeline vim: nu

# #########################################
#
# Execute the qidtrace and similar programs;
# and store data about each run in a file 
# in CSV format, and in a table data structure.
#
#
# Ref: Perl Testing, A Developer''s Notebook, p. 167:
#   Testing Programs using IPC::Run.
#
# #########################################

# Note, Thu2011_0929_23:19
#TBD: Build this test into a tool that runs the PUT & analyzes
# the o/p & builds an o/p data file.
# It should append test results to the o/p file, for easy
# comparison of various runs of the Program Under Test.
#
# Status:
# Done: Run the program using IPC.
# Done: Save its o/p to a file.
# Done: Implement command line args to set some values.
#

use warnings;
use strict;

use IPC::Run 'run';

use Getopt::Long;

my $DEBUG = 0;    # Set to 1 to enable debug stmts.
                  # Set to 0 to run tests & for normal operation.

my $TST = 1;    # TBD: Not yet coded: Set to 0 to disable testing & run all data.
                # Set to 1 to run quickly, w/ minimal settings.
                # TBD: Not yet coded: Set to 2 to run more values for each parameter.
                # Set to 9 to run the most values for each parameter.

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any

# Specify Program Under Test, put.
my $putdir  = "bin/";
my $put     = "qidtrace";
my $putfile = $putdir . $put;

my @puts;
@puts = qw{ bin/qidtrace } if ($TST==1);
@puts = qw{ bin/two_buffer_pg_rev2.pl
    bin/two_pass_tracer_debug_pg_rev2.pl  bin/qidtrace
} if ($TST==9);

my @uids;
@uids = qw{ u13@h2.net u13@h362.com } if ($TST == 1);
@uids          = qw{ u13@h2.net u13@h362.com u3792@h1250.com 
    u3815@h1250.com u3814@h1250.com u15069@h2.net u207@h208.com
    u18287@h1056.net u1669@h2.net u364428@h567.net u364428@h567.NET 
    u4076@h1250.com
    u7510@h656.net u7539@h573.com
} if ($TST == 9);

my @wins;
@wins = qw{ 1400 }                  if ($TST == 1);
@wins        = qw{ 1400 2600 4000 } if ($TST == 9);

my $indir = "data/";
my @infiles;
my @datafiles;
@datafiles = qw{ 11-lines.mx 99-lines.mx } if ($TST == 1);
@datafiles = qw{ 4500k-lines.mx }          if ($TST == 9);
foreach my $f (@datafiles) {
    push @infiles, $indir . $f;
}

#TBD: Make this program a wrapper around different implementations of qidtrace.
#  Use minimal editing of the wrapped code.
#TBD?: Use chdir to set the current dir before a test run.

my $row_num = 0;

# Define table (AoH refs) to hold settings & o/p data.
my  $oTable000  = [];
my  $oRow       = {
    'put'        =>  'qidtrace',
    'win'        =>  1400,
    'infile'     =>  '4500k-lines.mx',
    'uid'        =>  'u13@h2.net',
    'line_count' =>   0,
    'duration'   =>   0,
    };


# Run the PUT

foreach my $p (@puts) {
    foreach my $w (@wins) {
        foreach my $i (@infiles) {
            foreach my $u (@uids) {

                my ( $out, $err );
                ( $out, $err )
                    = runqid( qw{-I lib}, $p, '-m', $u, '-w', $w, $i );

             # Analyze o/p to get summary data: o/p line count, duration, TBD.
                my $line_count = 0;
                foreach ( split /\n/, $out ) {
                    $line_count++;
                }

                my $duration = "TBD-duration";
                if ( $err
                    =~ /^.*? user \s+ .*? system \s+ (.*?) elapsed \s+/x )
                {
                    $duration = $1;
                }

                # Populate table with data from each run.
                    $oRow->{put}        = $p;
                    $oRow->{win}        = $w;
                    $oRow->{infile}     = $i;
                    $oRow->{uid}        = $u;
                    $oRow->{line_count} = $line_count;
                    $oRow->{duration}   = $duration;
                    #TBR $oRow->{typeof}     = ${[qw(production development)]}[int(rand(2))];
                    my %hCurrent        = %{$oRow};
                    $oTable000->[$row_num] = \%hCurrent;
                    $row_num++;


                #TBD: Read time stamp of PUT & add it to summary o/p.
                #TBD: ?Read version of PUT & add it to summary o/p?

                # Write header line to a separate o/p file.
                my $outdir = "out";
                sleep 1
                    ; # To avoid overwriting o/p files when small data sets are used.
                my $time_stamp  = build_tss();
                my $out_suffix  = "$time_stamp.out";
                my $outfile     = "$outdir/qt.drive_qid." . $out_suffix;
                my $sum_outfile = "$outdir/drive_qid_summary";
                my $sum_out_header_file = "$outdir/qid_summary_header";
                my $sum_out_header
                    = "Date&Time of test, program, email_address, i/p file,"
                    . " window_size, o/p line_count, prog duration\n";
                open OUT, '>', $sum_out_header_file
                    or die "Cannot open $sum_out_header_file: [$!]\n";
                print OUT $sum_out_header;
                close OUT;

                # Append summary data to summary o/p file.
                my $sum_out
                    = "$time_stamp, $p, $u, $i, $w, $line_count, $duration\n";
                open OUT, '>>', $sum_outfile
                    or die "Cannot open $sum_outfile: [$!]\n";
                print OUT $sum_out;
                close OUT;

                print $sum_out_header;
                print $sum_out;
                print "\n";

                # Write each $out to unique o/p file
                open OUT, '>', $outfile or die "Cannot open $outfile: [$!]\n";
                print OUT $out;
                close OUT;

                #DBG print "DBG: \$out: ,$out, \n";
            }
        }
    }
}    # End foreach @put


# Print the raw table structure to a file for later use.
use Data::Dumper;
my $dump_data = Dumper( $oTable000 );
my $now = build_tss();
my $dump_suffix  = "$now.out";
my $dump_file = "/home/clpoda/p/qidtrace/out/dump_drive_qid_" . $dump_suffix;
open OUT, '>', $dump_file  or die "Cannot open $dump_file: $!\n";
print OUT $dump_data;
close OUT;


=begin filter

# Filter the table data (do whatever querying or grouping you want here).
#TBD: Group together line count & duration for each set of uid & win i/p
# settings, for put1, put2, and put3; so that a row can be printed out
# w/ data from 3 different put's on one line.
@{$oTable000} =
    ### SORT BY
    sort { $a->{put} cmp  $b->{put}}
    ### WHERE typeof = 'development'
    #ORG grep { $_->{typeof} eq 'development';}
    grep { $_->{win} eq 1400;}

    @{$oTable000};

=end filter

=cut


# Process the table data.
print ("\nOutput from table data structure.\n");
print ("  i/p file is 4500k lines.\n");
print ("  put1,2,3: PG's two-buffer, PG's two-pass, CP's qidtrace.\n");
#TBD printf ("%15s %6s %10s %10s", "uid", "win", "put1"  put1, put2  put2, put3  put3\n");
print (" " x 15, "uid   win     put1       put1\n");
#TBD printf ("%21s %10s %10s", "", "lines",  "time", lines time, lines time\n");
print (" " x 29, "lines      time\n");
foreach my $oRec (@{$oTable000}){
    printf ("%18s", $oRec->{uid});
    printf ("%6s",  $oRec->{win});
    printf ("%10s", $oRec->{line_count});
    printf ("%10s", $oRec->{duration});
    print "\n";
};



exit;

sub runqid {
    run( [ "/usr/bin/time", $^X, @_ ], \my ( $in, $out, $err ) );

    #DBG print "DBG-runqid:  /usr/bin/time, $^X, @_ \n";
    #DBG print "DBG-runqid:  \$out: ,,$out,,\n";
    #DBG print "DBG-runqid:  \$err: ,,$err,,\n";
    return ( $out, $err );
}

sub build_tss {
    #########################################################
    # Usage      : TBD
    # Purpose    : Build time stamp string $tss, w/ leading zeros
    # Returns    : $tss, a string like YYYYMMDD_HHMM
    # Parameters : none; uses current time.
    # Throws     : no exceptions
    # Comments   : none
    # Status     : Working.
    # See Also   : n/a
    #########################################################
    #
    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst )
        = localtime(time);
    $year += 1900;
    $mon  += 1;
    my $i;
    for $i ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) {
        $i = "0" . $i if $i <= 9;
    }
    my $tss = $year . "_" . $mon . $mday . "_" . "$hour:$min:$sec";
    return $tss;
}

sub usage {
    return <<"eousage";
Usage:
  $prog: [options] -m match_string <log_files>

$prog is a driver to run qidtrace.
It can specify one or more sets of input parameters, and collects the o/p.

Options to control the matching

-match-pattern string    log lines are matched against this literal 
                         (not regex) pattern.  typical usage is an email
                         address, or a virus name.
                         Required.

-window-size   int       a window of log lines both in front of, and 
                         behind the current line is kept.  Matches will be
                         found in this buffer.
                         Default: 100

eousage
}

