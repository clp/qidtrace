#! /usr/bin/env perl

use strict;
use warnings;

our $VERSION = '0.02';

my $DEBUG = 0;    # Set to 1 to enable debug stmts.
                  # Set to 0 to run tests & for normal operation.

my $prog = $0;
$prog =~ s{\A.*/}{};    # strip leading path, if any

die usage() if ( !@ARGV );

my $total_line_count;
my %uid;
my %qid;
my @frequent_uids;
my @frequent_qids;

while (<>) {
    chomp;
    $total_line_count++;
    my $line = $_;

    #DBG print "DBG.while: \$.: ,$.,\n" if ($DEBUG);
    #DBG print "DBG.while: \$line: ,$line,\n" if ($DEBUG);

    #
    # Chk for qid first.
    if ( $line =~ m/.*:? ([a-zA-Z\d]{14}).? ?.*/ ) {
        $qid{$1}++;
    }

    # Chk for empty email before non-empty
    # & read next i/p line if match found here.
    if ( $line =~ m/(<>)/ ) {

        #DBG print "DBG.empty.email_hash: \$1: ,<>,\n" if ($DEBUG);
        $uid{'<>'}++;
        next;
    }

    #
    # Chk for non-empty email last to avoid counting empty lines twice.
    if ( $line =~ m/(<.*?\@.*?>)/ ) {

        #DBG print "DBG.email_hash: \$1: ,$1,\n" if ($DEBUG);
        $uid{$1}++;
    }

}    # End of while loop.

# Sort the hash by values.
@frequent_uids = sort { $uid{$b} <=> $uid{$a} } keys %uid;
@frequent_qids = sort { $qid{$b} <=> $qid{$a} } keys %qid;

print "$frequent_uids[$_]: $uid{$frequent_uids[$_]}\n" foreach ( 0 .. 9 );
print "$frequent_qids[$_]: $qid{$frequent_qids[$_]}\n" foreach ( 0 .. 9 );

exit;

sub usage {
    return <<"eousage";
Usage:
  $prog <log_file>

$prog is a filter for sendmail log files.
It counts each email address and queue id string,
and prints the most frequent ones found.

eousage
}

